import { Context } from 'telegraf';
import { config } from '../../core/config';
import { rateLimiter } from '../../core/rateLimit';
import { makeSessionDir, safeRemove } from '../../core/fs';
import { ensureBelowLimit } from '../../core/size';
import { translateInstagramReel } from '../../workflows/reelTranslate';
import {
  TranslationDirection,
  TranslationEngine,
  TranslationMode,
  TranslationOptions,
  TranslationStage,
} from '../../types/translation';
import { AppError, toUserMessage } from '../../core/errors';
import { logger } from '../../core/logger';
import * as path from 'path';
import { translationIntents } from '../telegraf';
import { mainKeyboard } from '../../ui/keyboard';
import { VoicePreset } from '../../types/voice';

const stageLabels: Record<TranslationStage['name'], string> = {
  download: '–°–∫–∞—á–∏–≤–∞—é –≤–∏–¥–µ–æ',
  separate: '–†–∞–∑–¥–µ–ª—è—é –≥–æ–ª–æ—Å –∏ –º—É–∑—ã–∫—É (LALAL.AI)',
  'analyze-audio': '–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –≥–æ–ª–æ—Å –∏ –ø–∞—É–∑—ã',
  transcribe: '–†–∞—Å–ø–æ–∑–Ω–∞—é —Ä–µ—á—å (Whisper)',
  translate: '–ü–µ—Ä–µ–≤–æ–∂—É —Ç–µ–∫—Å—Ç (ChatGPT)',
  synthesize: '–û–∑–≤—É—á–∏–≤–∞—é –ø–µ—Ä–µ–≤–æ–¥ (Hume)',
  'elevenlabs-dub': '–û–∑–≤—É—á–∏–≤–∞—é —á–µ—Ä–µ–∑ ElevenLabs',
  mux: '–°–æ–±–∏—Ä–∞—é –≤–∏–¥–µ–æ —Å –Ω–æ–≤–æ–π –æ–∑–≤—É—á–∫–æ–π',
  'select-voice': '–í—ã–±–∏—Ä–∞—é –≥–æ–ª–æ—Å –¢–µ—Ä–º–∏–Ω–∞—Ç–æ—Ä–∞',
};

function parseDirection(token?: string): TranslationDirection {
  if (!token) return 'auto';
  const normalized = token.trim().toLowerCase();
  if (normalized === 'en-ru' || normalized === 'enru' || normalized === 'en_ru') return 'en-ru';
  if (normalized === 'ru-en' || normalized === 'ruen' || normalized === 'ru_en') return 'ru-en';
  if (normalized === 'identity-ru' || normalized === 'dubbing-ru') return 'identity-ru';
  if (normalized === 'identity-en' || normalized === 'dubbing-en') return 'identity-en';
  if (normalized === 'auto') return 'auto';
  return 'auto';
}

function deriveMode(direction: TranslationDirection): TranslationMode {
  return direction === 'identity-ru' || direction === 'identity-en' ? 'dubbing' : 'translate';
}

function normalizeVoicePresetToken(token?: string, direction?: TranslationDirection): VoicePreset['id'] | undefined {
  if (!token) return undefined;
  const normalized = token.trim().toLowerCase();
  if (normalized === 'terminator' || normalized === 'terminator-ru') return 'terminator-ru';
  if (normalized === 'terminator-en') return 'terminator-en';
  if (normalized === 'terminator-auto') {
    if (direction === 'ru-en' || direction === 'identity-en') return 'terminator-en';
    return 'terminator-ru';
  }
  return undefined;
}

function parseEngineAndVoice(
  token: string | undefined,
  direction: TranslationDirection
): { engine: TranslationEngine; voicePreset?: VoicePreset['id'] } {
  const voicePreset = normalizeVoicePresetToken(token, direction);
  if (voicePreset) {
    return { engine: 'elevenlabs', voicePreset };
  }

  if (!token) {
    return { engine: 'hume' };
  }

  const normalized = token.trim().toLowerCase();
  if (normalized.startsWith('eleven') || normalized.includes('elevenlabs')) {
    return { engine: 'elevenlabs' };
  }
  if (normalized === 'hume' || normalized === 'fast') {
    return { engine: 'hume' };
  }
  if (normalized === 'terminator') {
    const preset =
      direction === 'ru-en' || direction === 'identity-en' ? 'terminator-en' : ('terminator-ru' as VoicePreset['id']);
    return { engine: 'elevenlabs', voicePreset: preset };
  }
  return { engine: 'hume' };
}

function describeVoice(preset?: VoicePreset['id']): string | undefined {
  if (!preset) return undefined;
  if (preset === 'terminator-ru') return 'Terminator (RU)';
  if (preset === 'terminator-en') return 'Terminator (EN)';
  return preset;
}

export async function translateCommand(ctx: Context): Promise<void> {
  const userId = ctx.from?.id;
  const username = ctx.from?.username;

  if (!config.ENABLE_REEL_TRANSLATION) {
    await ctx.reply('‚öôÔ∏è –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ä–∏–ª—Å–æ–≤ –ø–æ–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ ENABLE_REEL_TRANSLATION=1, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å –µ—ë.');
    return;
  }

  if (!userId) {
    await ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.');
    return;
  }

  const messageText = ctx.message && 'text' in ctx.message ? ctx.message.text : '';
  const args = messageText.split(' ').slice(1).filter(Boolean);
  const url = args[0];
  const direction = parseDirection(args[1]);
  const { engine, voicePreset } = parseEngineAndVoice(args[2], direction);
  const mode = deriveMode(direction);

  if (!url) {
    await ctx.reply(
      '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /translate <—Å—Å—ã–ª–∫–∞ –Ω–∞ —Ä–∏–ª—Å> [en-ru|ru-en|identity-ru|identity-en|auto] [hume|elevenlabs|terminator-ru|terminator-en]'
    );
    return;
  }

  const options: TranslationOptions = {
    direction,
    engine,
    mode,
    ...(voicePreset ? { voicePreset } : {}),
  };

  logger.info('Translate command received', {
    userId,
    username,
    url,
    direction,
    engine,
    mode,
    voicePreset,
  });

  const status = rateLimiter.getStatus(userId);
  if (status.active >= 2) {
    await ctx.reply('‚è∏Ô∏è –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–µ—Ä–µ–≤–æ–¥–æ–≤. –î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–∏—Ö –∑–∞–¥–∞—á.');
    return;
  }

  const release = await rateLimiter.acquire(userId);

  const chatId = ctx.chat?.id;
  let statusMessageId: number | undefined;
  const progressLines: string[] = [];

  const appendProgress = async (line: string) => {
    progressLines.push(line);
    if (!chatId || statusMessageId === undefined) return;
    try {
      await ctx.telegram.editMessageText(chatId, statusMessageId, undefined, `üåê –ü–µ—Ä–µ–≤–æ–¥ —Ä–∏–ª—Å–∞\n\n${progressLines.join('\n')}`);
    } catch (error) {
      logger.warn('Failed to edit translation status message', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  };

  try {
    const statusMessage = await ctx.reply('üåê –ü–µ—Ä–µ–≤–æ–¥ —Ä–∏–ª—Å–∞ –∑–∞–ø—É—â–µ–Ω...');
    statusMessageId = statusMessage.message_id;

    const sessionDir = await makeSessionDir();

    try {
      const stageObserver = async (stage: TranslationStage) => {
        const label = stageLabels[stage.name] || stage.name;
        const icon = stage.error ? '‚ùå' : '‚úÖ';
        await appendProgress(`${icon} ${label}`);
      };

      const result = await translateInstagramReel(
        url,
        sessionDir,
        options,
        stageObserver
      );

      await ensureBelowLimit(result.videoPath);

      const fileName = path.basename(result.videoPath);
      await ctx.replyWithDocument(
        { source: result.videoPath, filename: fileName },
        statusMessageId
          ? {
              reply_parameters: {
                message_id: statusMessageId,
              },
            }
          : undefined
      );

      if (statusMessageId) {
        await appendProgress('üéâ –ì–æ—Ç–æ–≤–æ!');
        const voiceDescription = describeVoice(result.voicePreset);
        if (voiceDescription) {
          await appendProgress(`üéô –ì–æ–ª–æ—Å: ${voiceDescription}`);
        }
      }
    } finally {
      await safeRemove(sessionDir);
    }
  } catch (error) {
    const appError = error instanceof AppError ? error : undefined;
    const rawCause = appError && appError.details && typeof appError.details === 'object' && 'cause' in appError.details
      ? (appError.details as Record<string, unknown>)['cause']
      : undefined;

    logger.error(
      {
        errorMessage: error instanceof Error ? error.message : String(error),
        errorStack: error instanceof Error ? error.stack : undefined,
        errorCode: appError?.code,
        errorDetails: appError?.details,
        causeMessage: rawCause instanceof Error ? rawCause.message : rawCause && typeof rawCause === 'object' && 'message' in rawCause ? (rawCause as any).message : undefined,
        causeStack: rawCause instanceof Error ? rawCause.stack : undefined,
        userId,
        username,
        url,
      },
      'Translation command failed'
    );

    let message: string;
    if (error instanceof AppError) {
      message = toUserMessage(error);
    } else {
      message = '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.';
    }

    await ctx.reply(message);
  } finally {
    release();
    translationIntents.delete(userId);
    await ctx.reply('–ì–æ—Ç–æ–≤–æ. –í—ã–±–µ—Ä–∏—Ç–µ –¥–∞–ª—å–Ω–µ–π—à–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ.', {
      reply_markup: mainKeyboard.reply_markup,
    });
  }
}
