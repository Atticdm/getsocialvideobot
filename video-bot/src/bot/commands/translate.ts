import { Context } from 'telegraf';
import { config } from '../../core/config';
import { rateLimiter } from '../../core/rateLimit';
import { makeSessionDir, safeRemove } from '../../core/fs';
import { ensureBelowLimit } from '../../core/size';
import { translateInstagramReel } from '../../workflows/reelTranslate';
import { TranslationDirection, TranslationStage } from '../../types/translation';
import { AppError, toUserMessage } from '../../core/errors';
import { logger } from '../../core/logger';
import * as path from 'path';

const stageLabels: Record<TranslationStage['name'], string> = {
  download: '–°–∫–∞—á–∏–≤–∞—é –≤–∏–¥–µ–æ',
  'extract-audio': '–ò–∑–≤–ª–µ–∫–∞—é –∞—É–¥–∏–æ –¥–æ—Ä–æ–∂–∫—É',
  'analyze-audio': '–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –≥–æ–ª–æ—Å –∏ –ø–∞—É–∑—ã',
  transcribe: '–†–∞—Å–ø–æ–∑–Ω–∞—é —Ä–µ—á—å (Whisper)',
  translate: '–ü–µ—Ä–µ–≤–æ–∂—É —Ç–µ–∫—Å—Ç (ChatGPT)',
  synthesize: '–û–∑–≤—É—á–∏–≤–∞—é –ø–µ—Ä–µ–≤–æ–¥ (Hume)',
  mux: '–°–æ–±–∏—Ä–∞—é –≤–∏–¥–µ–æ —Å –Ω–æ–≤–æ–π –æ–∑–≤—É—á–∫–æ–π',
};

function parseDirection(token?: string): TranslationDirection {
  if (!token) return 'auto';
  const normalized = token.trim().toLowerCase();
  if (normalized === 'en-ru' || normalized === 'enru' || normalized === 'en_ru') return 'en-ru';
  if (normalized === 'ru-en' || normalized === 'ruen' || normalized === 'ru_en') return 'ru-en';
  if (normalized === 'auto') return 'auto';
  return 'auto';
}

export async function translateCommand(ctx: Context): Promise<void> {
  const userId = ctx.from?.id;
  const username = ctx.from?.username;

  if (!config.ENABLE_REEL_TRANSLATION) {
    await ctx.reply('‚öôÔ∏è –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ä–∏–ª—Å–æ–≤ –ø–æ–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ ENABLE_REEL_TRANSLATION=1, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å –µ—ë.');
    return;
  }

  if (!userId) {
    await ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.');
    return;
  }

  const messageText = ctx.message && 'text' in ctx.message ? ctx.message.text : '';
  const args = messageText.split(' ').slice(1).filter(Boolean);
  const url = args[0];
  const direction = parseDirection(args[1]);

  if (!url) {
    await ctx.reply('–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /translate <—Å—Å—ã–ª–∫–∞ –Ω–∞ —Ä–∏–ª—Å> [en-ru|ru-en|auto]');
    return;
  }

  logger.info('Translate command received', { userId, username, url, direction });

  // Rate limiting
  const status = rateLimiter.getStatus(userId);
  if (status.active >= 2) {
    await ctx.reply('‚è∏Ô∏è –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–µ—Ä–µ–≤–æ–¥–æ–≤. –î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–∏—Ö –∑–∞–¥–∞—á.');
    return;
  }

  const release = await rateLimiter.acquire(userId);

  const chatId = ctx.chat?.id;
  let statusMessageId: number | undefined;
  const progressLines: string[] = [];

  const appendProgress = async (line: string) => {
    progressLines.push(line);
    if (!chatId || statusMessageId === undefined) return;
    try {
      await ctx.telegram.editMessageText(chatId, statusMessageId, undefined, `üåê –ü–µ—Ä–µ–≤–æ–¥ —Ä–∏–ª—Å–∞\n\n${progressLines.join('\n')}`);
    } catch (error) {
      logger.warn('Failed to edit translation status message', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  };

  try {
    const statusMessage = await ctx.reply('üåê –ü–µ—Ä–µ–≤–æ–¥ —Ä–∏–ª—Å–∞ –∑–∞–ø—É—â–µ–Ω...');
    statusMessageId = statusMessage.message_id;

    const sessionDir = await makeSessionDir();

    try {
      const stageObserver = async (stage: TranslationStage) => {
        const label = stageLabels[stage.name] || stage.name;
        const icon = stage.error ? '‚ùå' : '‚úÖ';
        await appendProgress(`${icon} ${label}`);
      };

      const result = await translateInstagramReel(
        url,
        sessionDir,
        { direction },
        stageObserver
      );

      await ensureBelowLimit(result.videoPath);

      const fileName = path.basename(result.videoPath);
      await ctx.replyWithDocument(
        { source: result.videoPath, filename: fileName },
        statusMessageId
          ? {
              reply_parameters: {
                message_id: statusMessageId,
              },
            }
          : undefined
      );

      if (statusMessageId) {
        await appendProgress('üéâ –ì–æ—Ç–æ–≤–æ!');
      }

      // if (result.translatedText) {
      //   const text = result.translatedText.length > 3500
      //     ? `${result.translatedText.slice(0, 3500)}‚Ä¶`
      //     : result.translatedText;
      //   await ctx.reply(`üìù –ü–µ—Ä–µ–≤–æ–¥:\n\n${text}`);
      // }

      logger.info('Translation workflow completed', {
        userId,
        url,
        stages: result.stages,
        sessionDir,
      });
    } finally {
      await safeRemove(sessionDir);
    }
  } catch (error) {
    logger.error('Translation command failed', {
      error,
      userId,
      username,
      url,
    });

    let message: string;
    if (error instanceof AppError) {
      message = toUserMessage(error);
    } else {
      message = '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.';
    }

    await ctx.reply(message);
  } finally {
    release();
  }
}
