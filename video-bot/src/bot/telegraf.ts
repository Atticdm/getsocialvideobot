import { Telegraf } from 'telegraf';
import type { Context } from 'telegraf';
import { config } from '../core/config';
import { logger } from '../core/logger';
import { ensureTempDir } from '../core/fs';
import { run } from '../core/exec';
import { startCommand } from './commands/start';
import { helpCommand } from './commands/help';
import { statusCommand } from './commands/status';
import { downloadCommand } from './commands/download';
import { diagCommand } from './commands/diag';
import { translateCommand } from './commands/translate';
import { TranslationDirection, TranslationEngine, TranslationMode } from '../types/translation';
import type { VoicePreset } from '../types/voice';
import {
  modeChoiceKeyboard,
  mainKeyboard,
  translationKeyboard,
  removeKeyboard,
  voiceChoiceKeyboard,
  dubbingLanguageKeyboard,
} from '../ui/keyboard';
import { getVoiceIdForPreset } from '../services/elevenlabs';
import { setupInlineHandlers } from './inline';

type EntryPreference = 'standard' | 'voice';

type TranslationIntent =
  | { stage: 'direction'; preference: EntryPreference }
  | { stage: 'dubbing-language'; preference: EntryPreference }
  | { stage: 'mode'; direction: TranslationDirection; mode: TranslationMode }
  | { stage: 'voice'; direction: TranslationDirection; mode: TranslationMode; engine: TranslationEngine }
  | { stage: 'ready'; direction: TranslationDirection; mode: TranslationMode; engine: TranslationEngine; voicePreset?: VoicePreset['id'] };

export const bot = new Telegraf(config.BOT_TOKEN!);

let handlersRegistered = false;
let signalsRegistered = false;
export const translationIntents = new Map<number, TranslationIntent>();

async function logToolVersions(): Promise<void> {
  try {
    const ytdlpVersion = await run('yt-dlp', ['--version']);
    const ffmpegVersion = await run('ffmpeg', ['-version']);
    logger.info(
      {
        'yt-dlp': ytdlpVersion.stdout.trim(),
        ffmpeg: ffmpegVersion.stdout.split('\n')[0],
      },
      'Tool versions'
    );
  } catch (error) {
    logger.error(error, 'Failed to check tool versions on startup');
  }
}

function ensureSignals(): void {
  if (signalsRegistered) return;
  signalsRegistered = true;
  process.once('SIGINT', () => {
    logger.info('Received SIGINT, shutting down gracefully');
    bot.stop('SIGINT');
  });

  process.once('SIGTERM', () => {
    logger.info('Received SIGTERM, shutting down gracefully');
    bot.stop('SIGTERM');
  });
}

export async function setupBot(): Promise<void> {
  if (handlersRegistered) return;
  handlersRegistered = true;

  bot.command('start', startCommand);
  bot.command('help', helpCommand);
  bot.command('status', statusCommand);
  bot.command('download', downloadCommand);
  bot.command('dl', downloadCommand);
  bot.command('get', downloadCommand);
  bot.command('diag', diagCommand);
  bot.command('translate', translateCommand);

  setupInlineHandlers(bot);

  const ensureTranslationEnabled = async (ctx: Context) => {
    if (!config.ENABLE_REEL_TRANSLATION) {
      await ctx.reply(
        '‚öôÔ∏è –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ä–∏–ª—Å–æ–≤ –ø–æ–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ ENABLE_REEL_TRANSLATION=1, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å –µ—ë.'
      );
      return false;
    }
    return true;
  };

  const registerTranslationDirection = async (ctx: Context, direction: TranslationDirection) => {
    const userId = ctx.from?.id;
    if (!userId) {
      await ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.');
      return;
    }

    const enabled = await ensureTranslationEnabled(ctx);
    if (!enabled) return;

    const intent = translationIntents.get(userId);
    if (!intent || (intent.stage !== 'direction' && intent.stage !== 'dubbing-language')) {
      await ctx.reply('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –ø–µ—Ä–µ–≤–æ–¥–∞.', {
        reply_markup: mainKeyboard.reply_markup,
      });
      return;
    }

    const mode: TranslationMode = direction.startsWith('identity') ? 'dubbing' : 'translate';
    translationIntents.set(userId, { stage: 'mode', direction, mode });

    if (mode === 'translate') {
      const directionLabel =
        direction === 'en-ru'
          ? '–∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ –Ω–∞ —Ä—É—Å—Å–∫–∏–π'
          : direction === 'ru-en'
          ? '—Ä—É—Å—Å–∫–æ–≥–æ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π'
          : '–≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è';
      await ctx.reply(`–û—Ç–ª–∏—á–Ω—ã–π –≤—ã–±–æ—Ä! –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ —Ç–∏–ø –ø–µ—Ä–µ–≤–æ–¥–∞ –¥–ª—è ${directionLabel}.`, {
        reply_markup: modeChoiceKeyboard.reply_markup,
      });
    } else {
      await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ–∑–≤—É—á–∫–∏ –¥–ª—è –ø–µ—Ä–µ–æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è —Ä–æ–ª–∏–∫–∞:', {
        reply_markup: modeChoiceKeyboard.reply_markup,
      });
    }
  };

  const startDirectionSelection = async (ctx: Context, preference: EntryPreference) => {
    const userId = ctx.from?.id;
    if (!userId) {
      await ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.');
      return;
    }
    const enabled = await ensureTranslationEnabled(ctx);
    if (!enabled) return;

    translationIntents.set(userId, { stage: 'direction', preference });
    await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞:', {
      reply_markup: translationKeyboard.reply_markup,
    });
  };

  bot.hears('üåê Translate', async (ctx) => startDirectionSelection(ctx, 'standard'));
  bot.hears('üéô –ü–µ—Ä–µ–≤–æ–¥ —Å –æ–∑–≤—É—á–∫–æ–π', async (ctx) => startDirectionSelection(ctx, 'voice'));

  bot.hears('üá¨üáß ‚Üí üá∑üá∫', (ctx) => registerTranslationDirection(ctx, 'en-ru'));
  bot.hears('üá∑üá∫ ‚Üí üá¨üáß', (ctx) => registerTranslationDirection(ctx, 'ru-en'));

  bot.hears('üé¨ –ü–µ—Ä–µ–æ–∑–≤—É—á–∏—Ç—å', async (ctx) => {
    const userId = ctx.from?.id;
    if (!userId) {
      await ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.');
      return;
    }
    const enabled = await ensureTranslationEnabled(ctx);
    if (!enabled) return;

    translationIntents.set(userId, { stage: 'dubbing-language', preference: 'voice' });
    await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –¥–ª—è –ø–µ—Ä–µ–æ–∑–≤—É—á–∫–∏:', {
      reply_markup: dubbingLanguageKeyboard.reply_markup,
    });
  });

  bot.hears('üá∑üá∫ –û–∑–≤—É—á–∏—Ç—å —Ä—É—Å—Å–∫–∏–º –≥–æ–ª–æ—Å–æ–º', (ctx) => registerTranslationDirection(ctx, 'identity-ru'));
  bot.hears('üá¨üáß –û–∑–≤—É—á–∏—Ç—å –∞–Ω–≥–ª–∏–π—Å–∫–∏–º –≥–æ–ª–æ—Å–æ–º', (ctx) => registerTranslationDirection(ctx, 'identity-en'));

  const registerModeChoice = async (ctx: Context, choice: 'hume' | 'elevenlabs' | 'terminator') => {
    const userId = ctx.from?.id;
    if (!userId) {
      await ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.');
      return;
    }

    const intent = translationIntents.get(userId);
    if (!intent || intent.stage !== 'mode') {
      await ctx.reply('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞.', {
        reply_markup: translationKeyboard.reply_markup,
      });
      return;
    }

    const { direction, mode } = intent;

    if (choice === 'hume') {
      if (mode === 'dubbing') {
        await ctx.reply('–†–µ–∂–∏–º Hume –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø–µ—Ä–µ–æ–∑–≤—É—á–∏–≤–∞–Ω–∏–µ –±–µ–∑ –ø–µ—Ä–µ–≤–æ–¥–∞. –í—ã–±–µ—Ä–∏—Ç–µ ElevenLabs.', {
          reply_markup: modeChoiceKeyboard.reply_markup,
        });
        return;
      }
      translationIntents.set(userId, { stage: 'ready', direction, mode, engine: 'hume' });
      await ctx.reply('–û—Ç–ª–∏—á–Ω–æ! –ü—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ Instagram Reel –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞.', {
        reply_markup: removeKeyboard.reply_markup,
      });
      return;
    }

    if (choice === 'elevenlabs') {
      translationIntents.set(userId, { stage: 'ready', direction, mode, engine: 'elevenlabs' });
      await ctx.reply('–û—Ç–ª–∏—á–Ω–æ! –ü—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ Instagram Reel –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.', {
        reply_markup: removeKeyboard.reply_markup,
      });
      return;
    }

    if (choice === 'terminator') {
      translationIntents.set(userId, { stage: 'voice', direction, mode: 'voice', engine: 'elevenlabs' });
      const voiceLanguage =
        direction === 'en-ru' || direction === 'identity-ru'
          ? 'ru'
          : direction === 'ru-en' || direction === 'identity-en'
          ? 'en'
          : 'ru';
      await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–ª–æ—Å –¥–ª—è –æ–∑–≤—É—á–∫–∏:', {
        reply_markup: voiceChoiceKeyboard(voiceLanguage).reply_markup,
      });
      return;
    }
  };

  bot.hears('üöÄ –ë—ã—Å—Ç—Ä—ã–π (Hume)', (ctx) => registerModeChoice(ctx, 'hume'));
  bot.hears('üíé –ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π (ElevenLabs)', (ctx) => registerModeChoice(ctx, 'elevenlabs'));
  bot.hears('üéØ –ì–æ–ª–æ—Å –¢–µ—Ä–º–∏–Ω–∞—Ç–æ—Ä–∞', (ctx) => registerModeChoice(ctx, 'terminator'));

  const registerVoicePreset = async (ctx: Context, preset: VoicePreset['id']) => {
    const userId = ctx.from?.id;
    if (!userId) {
      await ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.');
      return;
    }
    const intent = translationIntents.get(userId);
    if (!intent || intent.stage !== 'voice') {
      await ctx.reply('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –æ–∑–≤—É—á–∫–∏.', {
        reply_markup: mainKeyboard.reply_markup,
      });
      return;
    }

    const voiceId = getVoiceIdForPreset(preset);
    if (!voiceId) {
      const voiceLanguage =
        intent.direction === 'en-ru' || intent.direction === 'identity-ru'
          ? 'ru'
          : intent.direction === 'ru-en' || intent.direction === 'identity-en'
          ? 'en'
          : 'ru';
      await ctx.reply(
        '‚ùå –ì–æ–ª–æ—Å —Å–µ–π—á–∞—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ELEVENLABS_TERMINATOR_VOICE_RU / ELEVENLABS_TERMINATOR_VOICE_EN.',
        {
          reply_markup: voiceChoiceKeyboard(voiceLanguage).reply_markup,
        }
      );
      return;
    }

    translationIntents.set(userId, {
      stage: 'ready',
      direction: intent.direction,
      mode: intent.mode,
      engine: intent.engine,
      voicePreset: preset,
    });

    await ctx.reply('–ì–æ–ª–æ—Å –≤—ã–±—Ä–∞–Ω! –ü—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ä–æ–ª–∏–∫ –¥–ª—è –æ–∑–≤—É—á–∫–∏.', {
      reply_markup: removeKeyboard.reply_markup,
    });
  };

  bot.hears('ü§ñ Terminator (RU)', (ctx) => registerVoicePreset(ctx, 'terminator-ru'));
  bot.hears('ü§ñ Terminator (EN)', (ctx) => registerVoicePreset(ctx, 'terminator-en'));

  bot.hears('‚¨ÖÔ∏è Back', async (ctx) => {
    const userId = ctx.from?.id;
    if (!userId) {
      await ctx.reply('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.');
      return;
    }
    translationIntents.delete(userId);
    await ctx.reply('–†–µ–∂–∏–º –ø–µ—Ä–µ–≤–æ–¥–∞ –æ—Ç–∫–ª—é—á—ë–Ω.', {
      reply_markup: mainKeyboard.reply_markup,
    });
  });

  bot.on('text', async (ctx) => {
    const text = ctx.message?.text;
    const userId = ctx.from?.id;

    if (text && text.startsWith('http')) {
      if (userId && translationIntents.has(userId)) {
        const intent = translationIntents.get(userId)!;
        if (intent.stage === 'ready') {
          translationIntents.delete(userId);
          const token = intent.voicePreset ?? intent.engine;
          ctx.message.text = `/translate ${text} ${intent.direction} ${token}`;
          return translateCommand(ctx);
        }
        if (intent.stage === 'direction') {
          await ctx.reply('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞.', {
            reply_markup: translationKeyboard.reply_markup,
          });
          return;
        }
        if (intent.stage === 'dubbing-language') {
          await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –¥–ª—è –ø–µ—Ä–µ–æ–∑–≤—É—á–∫–∏:', {
            reply_markup: dubbingLanguageKeyboard.reply_markup,
          });
          return;
        }
        if (intent.stage === 'mode') {
          await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ–±—Ä–∞–±–æ—Ç–∫–∏:', {
            reply_markup: modeChoiceKeyboard.reply_markup,
          });
          return;
        }
        if (intent.stage === 'voice') {
          const voiceLanguage =
            intent.direction === 'en-ru' || intent.direction === 'identity-ru'
              ? 'ru'
              : intent.direction === 'ru-en' || intent.direction === 'identity-en'
              ? 'en'
              : 'ru';
          await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–ª–æ—Å –¥–ª—è –æ–∑–≤—É—á–∫–∏:', {
            reply_markup: voiceChoiceKeyboard(voiceLanguage).reply_markup,
          });
          return;
        }
      }

      ctx.message.text = `/download ${text}`;
      return downloadCommand(ctx);
    }

    if (userId && translationIntents.has(userId)) {
      const intent = translationIntents.get(userId)!;
      if (intent.stage === 'direction') {
        await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞:', {
          reply_markup: translationKeyboard.reply_markup,
        });
        return;
      }
      if (intent.stage === 'dubbing-language') {
        await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –¥–ª—è –ø–µ—Ä–µ–æ–∑–≤—É—á–∫–∏:', {
          reply_markup: dubbingLanguageKeyboard.reply_markup,
        });
        return;
      }
      if (intent.stage === 'mode') {
        await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –æ–±—Ä–∞–±–æ—Ç–∫–∏:', {
          reply_markup: modeChoiceKeyboard.reply_markup,
        });
        return;
      }
      if (intent.stage === 'voice') {
        const voiceLanguage =
          intent.direction === 'en-ru' || intent.direction === 'identity-ru'
            ? 'ru'
            : intent.direction === 'ru-en' || intent.direction === 'identity-en'
            ? 'en'
            : 'ru';
        await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–ª–æ—Å –¥–ª—è –æ–∑–≤—É—á–∫–∏:', {
          reply_markup: voiceChoiceKeyboard(voiceLanguage).reply_markup,
        });
        return;
      }
      if (intent.stage === 'ready') {
        await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ Instagram Reel –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞.', {
          reply_markup: removeKeyboard.reply_markup,
        });
        return;
      }
    }

    await ctx.reply("I don't understand that message. Use /help to see available commands.");
  });

  bot.catch((err, ctx) => {
    logger.error('Bot error', {
      error: err,
      userId: ctx.from?.id,
      username: ctx.from?.username,
      message: ctx.message && 'text' in ctx.message ? ctx.message.text : 'unknown',
    });

    ctx.reply('Sorry, something went wrong. Please try again.');
  });
}

export async function startPolling(): Promise<void> {
  await ensureTempDir();
  await setupBot();
  await logToolVersions();
  await bot.launch();
  ensureSignals();
  logger.info('Bot started successfully (long polling)');
}

export async function configureWebhook(publicUrl: string): Promise<void> {
  await ensureTempDir();
  await setupBot();
  await logToolVersions();
  const base = publicUrl.replace(/\/$/, '');
  await bot.telegram.setWebhook(`${base}/bot`);
  ensureSignals();
  logger.info({ webhookUrl: `${base}/bot` }, 'Webhook configured');
}
